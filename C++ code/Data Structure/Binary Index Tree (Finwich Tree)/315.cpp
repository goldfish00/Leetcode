/* 315. Count of Smaller Numbers After Self */
// Binary Tree / Fenwich Tree
/*
 * The idea of binary index tree / Finwich Tree is to store the partial incremental data using LSB (least significant bit)
 * When querying, the next index can be generated by subtracting the LSB from the previous index
 * When updating, the next index can be generated by adding the LSB to the previous index
 */

/*
 * This problem can be transformed into the following binary index tree:
 * 1. get the range of nums vector, and store an offset which equals to -min (turns the smallest value into zero)
 * 2. iterate nums vector from the last element to the first
 * 3. in the fenwich tree, caculate the cumulated number of vals of the current range, from [0, num + offset - 1]
 * 4. update the finwich tree by adding 1 to tree[num + offset]
 */
class Solution {
private:
    int offset;
    vector<int> fenTree;
    
    void initializeFenTree(const vector<int>& nums) {
        pair<int, int> minMax{nums.front(), nums.front()};
        for (const int& num : nums) {
            if (num < minMax.first) {
                minMax.first = num;
            } else if (num > minMax.second) {
                minMax.second = num;
            }
        }
        
        // Notice: fenwich tree is 1-based for lsb calculation
        offset = -minMax.first + 1;
        fenTree.resize(minMax.second - minMax.first + 2);
    }
    
    int lsb(const int& num) {
        return num & (-num);
    }
    
    void update(const int& num) {
        int adjustedNum = num + offset;
        while (adjustedNum < fenTree.size()) {
            fenTree[adjustedNum] += 1;
            adjustedNum += lsb(adjustedNum);
        }
    }
    
    int query(const int& num) {
        int adjustedNum = num + offset - 1;
        int cumulatedVal = 0;
        
        while (1) {
            cumulatedVal += fenTree[adjustedNum];
            adjustedNum -= lsb(adjustedNum);
            if (adjustedNum == 0) {
                break;
            }
        }
        return cumulatedVal;
    }
    
public:
    vector<int> countSmaller(vector<int>& nums) {
        if (nums.size() == 1) {
            return vector<int>{0};
        }
        
        initializeFenTree(nums);
        
        vector<int> res(nums.size(), 0);
        for (auto numsIt = nums.rbegin(), resIt = res.rbegin(); numsIt != nums.rend(); ++numsIt, ++resIt) {
            *resIt = query(*numsIt);
            update(*numsIt);
        }
        return res;
    }
};

int main() {
    vector<int> nums{5, 2, 6, 1};
    Solution S;
    S.countSmaller(nums);
    
    return 0;
}
